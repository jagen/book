# 第2章 迭代、归纳和递归

1. **迭代技术**。反复执行一系列操作的最简单方法就是使用迭代结构，比如C语言中的for语句。
2. **递归程序设计**。C语言及其他众多语言都允许函数递归，即函数可以直接或间接地调用自己。递归程序更易于编、分析和理解。
3. **归纳证明**。是用来表情命题为真的一项重要技术。
   我们有与变量n相关的命题S(n)，希望证明S(n)为真。要证明S(n)，首先要提供**依据**，也就是n为某个值时的命题S(n)。例如，我们可以领n=0，并证明命题S(0)。接着，我们必须对**归纳步骤**加以证明，我们要证明，对应参数某个值的命题S，是由对应参数前一个值的相同命题S得出的，也就是说，对所有的n≥0，可以从S(n)得到S(n+1)。
4. **程序正确性证明**。在计算机科学中，我们常希望能够证明与程序有关的命题S(n)为真，不管是采用正式的还是非正式的方式。
5. **归纳定义**。计算机科学中的很多重要概念，特别是那些涉及数据模型的，最好用归纳的形式来定义，也就是我们给出定义该概念最简单形式的基本规则，以及可以用来从该概念较小实例构建大实例的归纳规则。
6. **运行时间分析**。算法处理不同大小的输入所花的时长（算法的“运行时间”）是衡量其“优良性”的一项重要指标。当算法涉及递归时，我们会使用名为**递推方程**的公式，它是种归纳定义，可以预测算法处理不同大小的输入所花的时间。

## 迭代

**自定义**，就是指概念是依据自身定义或构建的。例如，表可以定义为空，或一个元素后跟一个表。
**依据-归纳**。递归函数通常都含有某种针对不需要递归调用的“依据”，以及需要一次或多次调用的“归纳”实例进行测试。

运用恰当的自定义不会出现悖论或循环性，因为自定义的子部分总是比被定义的对象“更小”。此外，在经过有限个通向更小部分的步骤后，就能到达依据情况，也就是自定义终止的地方。

如果某递归函数是有效的，那么从某种意义上讲，某一函数调用的参数必须要比调用该函数的函数副本的参数“更小”。还有，在经过若干次递归调用后，我们必须要让参数“小到”函数不再进行递归调用为止。

### 排序

只要表的元素有“小于”的顺序可言，也就是具备我们通常用符号“<”表示的关系，就可以对这些元素排序。
要比较两个字符串，通常是依据它们的词典顺序进行比较的。
**排序算法**接受任意的表作为输入，并生成对输入进行过排列的已排序表作为输出。

### 选择排序：一种迭代排序算法

假设要对一个具有n个整数的数组A按照非递减顺序排序。

1. 在第一次迭代中，我们在整个数组A[0..n-1]中找出（“选取”）一个最小元素，并将其与A[0]互换位置；
2. 在第二次迭代中，我们从A[1..n-1]中找出一个最小元素，并将其与A[1]互换位置。
3. 继续进行这种迭代。在开始第i+1次迭代式，A[0..i-1]已经是将A中较小的i个元素按照非递减顺序排序了，而数组中余下的元素则没有特定的顺序。

``` C
void SelectionSort(int A[], int n)
{
    int i, j, small, temp;
    for (i = 0; i < n-1; ++i) {
        /* 将small置为剩余最小元素第一次出现是的小标。 */
        small = i;
        for (j = i + 1; j < n; ++j)
            for (A[j] < A[small])
                small = j;
        /*
         * 到达这里时，small是A[i..n-1]中第一个最小元素的下标，
         * 现在交换A[small]与A[i]
         */
        temp = A[small];
        A[small] = A[i];
        A[i] = temp;
    }
}
```

在排序时，我们会对要排序的值进行比较操作。通常只对值的特定部分进行比较，而用于比较的这个部分就称为**键**。
