# 数据的存储结构和特征

## 1.1 表和索引分离型

所谓的表和索引分离型的存储结构其实就是堆表，即用来存储数据的表和为了快速查找特定数据而使用的索引完全作为不同的对象来存储。

从代价的角度来分析，由于需要执行两次查找，即键的查找和数据的查找，必然会存在额外的代价。

使用键和数据分离的方法在存储数据时不会受到索引的任何影响，从这一角度来看，又在很大程度上减少了代价的支出。

虽然为了便于今后查找，而需要花费时间和经历将物品的存放位置记录在手册中，但这件事情完全可以放在空闲时间去做。而在存放物品时，如果能不用顾忌其他而有限无条件地将物品放入抽屉，则会在很大程度上减轻存放时的负担。

**数据和索引分别独立存储的数据存储结构具有非常重要的意义。**

表和索引互相分离、各自作为不同的对象存储是关系型数据库中最常见的数据存储方式。尽管这种存储方式有一些缺点，但是它在有效管理海量数据方面却是最佳方式。

### 1.1.1 堆表的结构

数据由一个个的Block构成，每个Block按照预先设定的未使用空间比例值（PCTFREE）和已使用空间比例（PCTUSED）来确定该数据块是否进入Free List中。被放入Free List中的Block可以被插入数据。

数据的存储方式完全与数据值之间没有任何联系，只是按照先后顺序无条件地将其插入到数据块中。

如果一个Block不是空的，数据必须被存储在Block中的空余空间里。如果Block中没有可以用来存储一整行数据的连续空间，但又要确保能够把同一行数据存储在这个数据块里时，必须对该数据块中的全部数据执行空间再分配操作（Condensing）。**数据块的下方的Free Space，并不是为插入新数据而预留的空间，而是为修改操作预留的。**它是在定义数据块时，通过设置参数PCTFREE来指定的。

采用随机存储方式虽然在某种程度上减少了数据存储时的代价，但是我们并不只是以存储数据为最终目的，而是以数据的读取和灵活运用为目的，所以绝不能对数据读取时的代价置之不理。

代表一行数据的ROWID，可以由4个部分构成，即对象编号（Object No）、数据文件编号（Datafile No）、数据块编号（Block No）和数据槽编号（ Slot No）。

行的ROWID不是存储在表中而是被存储在索引中。

所谓的**表空间（Table Space）**是指逻辑性的存储空间，它就类似于小区所占用的土地，或者类似于为了给建筑综合福利设施而提前准备好的土地。这种土地的位置、大小、种类等都是由不同用途的地块组合而成的。同样，表空间是由一个或多个物理文件（Datafile）构成的。

表空间按照用途可以被划分为不同用途的段（Segment），在段里创建对象（Object）。对象必须被创建在于其用途相匹配的段中。

某个表或某个索引中的数据非常多时，为了便于管理，通常我们会为其创建分区（Partition），而所创建的各个分区都是作为独立的对象而存在的。当分区表中各个分区的空间使用超过了一个表空间的限制时，可以将这些分区存储在多个表空间中。但是，个别分区表或非分区表都必须被存储在同一个表空间中。

对数据文件的识别并不是利用绝对文件号来进行唯一识别的，而是以表空间为单位为其赋予了相对号码，仅在一个对象中用其来唯一识别各个数据文件。

依据ROWID的对象号和数据文件号就能找出行的物理存储位置，然后在此物理存储位置上依据数据块号码就能够查找出相应的数据块，最后在数据块中很容易就能够查找出指向该行的Slot号。ROWID并不是用来显示行具体的位置信息的，而只是用来显示这一行的Slot号而已。

无论数据块中行的位置如何发生变化，ROWID的值也不会发生任何变化。在存储数据时，尽量要确保某一行被连续地、不间断地存储在某个数据块中；否则，为了将同一行所占用的多个非连续的存储片连接起来是需要付出额外代价的。因此，当行的长度发生变化时，为了始终确保将同一行存储在连续的单一存储片上，只能在其所在的数据块中寻找能够存储该行的连续空余空间，并将其移动到该空间上来。尽管行的位置发生了变化，但是由于这种变化并没有对ROWID产生任何影响，所以这种变化是不需要付出任何额外代价的。

当行被移动到能够适合其存储的单一的、连续的存储片上的，由于只需要把当前Slot中的位置值变为新的位置值即可，所以行位置的随意变化不会对ROWID产生任何影响。如果行的存储位置经常发生变化，则会形成大量无法使用的小空闲碎片。尽管这些空闲碎片总的空间可能超过某个行所需要的存储空间，但是如果没有连续空闲空间能够满足新行的存储需要，那么新行仍然无法存储在这个数据块中，为了解决此类问题，在总空余空间足以存储某行但由于没有连续空间可用时，数据库系统会自动对此数据块中的全部数据执行**空间再分配操作**。

如果预先设置的空余空间过小，数据库系统就会频繁要求执行空间再分配操作，这就无形中增加了数据处理的负担。因此，即使行长变长的概率不大，只是会频繁的执行修改操作，也同样应当设置充足的空余空间（PCTTREE）。**设置充足的空余空间可以被认为是提高数据处理效率的重要手段之一**。

但是总有一个特殊情况，就是无论怎么操作，仍然无法将变成的行存储在当前数据块中，必须使用其他数据库时，就意味着必须更换ROWID，比较聪明的一个方法是利用旧ROWID寻找新的ROWID。这会导致为了读取这行数据需要读取两块数据，这与读取一个数据块相比增加了一倍代价，我们称这种现象为**行迁移（Migration）**。这种现象只有在删除行或表之后并重新为数据行分配空间时才能够消除。

与行迁移相似的概念为**行连接（Chain）**。倘若某个行所需要的存储空间大小超过一个数据块的空间大小时，无论使用什么样的方法也无法将其存储在同一个数据块中。此时，就必须把所需要的数据块连接在一起来存储这个较长的行，我们把这种方法称为行链接。

一般情况下，存储于数据块中的行的长度都是可变的。尤其是当行中具有NULL值时，对NULL值的修改是导致行长度发生变化的重要原因。**行长度的变化对DBMS而言，也就意味着为了确保行被存储在数据块中的单一存储片上，而努力调整预期匹配的位置**。对于这一操作而言，从DBMS的角度来看，是对行位置的调整；而从行自身的角度来看，是自身位置的移动。为了避免由于行位置的移动对索引产生影响，就必须使用前面所介绍的行迁移和行链接的方式来进行处理。由于在堆表结构中行迁移和行链接是无法避免的，所以无论哪种DBMS,都会以非常相似的方式来处理。

### 1.1.2 聚簇因子

堆表的最大特征就是数据的独立存储性，即数据的存储于数据值没有任何关联地被存储在磁盘的任意位置上。从另外一个侧面来看，该特征也意味着为了查询我们所需要的数据必然要在磁盘的多个位置上进行查找。

**随机存储方式就是数据所占据的位置分散在不同的数据块上**。

在这种存储状态下，查询相同数据所执行的物理读取数量会随着查询数据的分散程度而不同。例如，数据行1~10被分散存储在10个数据块与两个数据块相比较，虽然两种情况逻辑读取的数据行数（都是10行）是相同的，但在物理（I/O）读取的数据块数上却相差5倍。

在关系型数据库中，不论在何种情况下，每次最少都需要读取一个数据块。尽管我们每次要求读取的是行，但实际上每次读取的却是数据块。因此，如果能够在内存中命中我们所需要查询的数据行，则在很大程度上就能够减少物理I/O的数量。

数据被存储的越集中，数据读取效率越高；数据被存储得越分散，数据读取效率越低下。

数据的物理存储方式是数据存储时决定的，且物理存储方式只能按照一种顺序存储数据，所以顺序一旦被决定就不能根据读取条件而随心所欲地改变。不论我们采取何种存储方式来存储数据，最终都会使得每一个列值的存储集中程度与其他列值的存储集中程度之间出现一定的差异。

**聚簇因子是指，按照索引列值进行了排序的索引行序和对应表表中数据行序的相似程度。**

在所有的表类型中，尤其是在堆表中，聚簇因子显得格外重要。聚簇因子的大小对数据读取效率有着直接的影响。

通常对存储在表中的行执行删除操作并不会频繁出现，并且修改操作导致列的长度变短的情况也比较少见。通常我们会尽量重复使用现存数据而尽量避免新增数据，因此通常数据插入操作的情况同样也比我们想象的要少（这种现象虽然会随着表特征的不同而不同，但是通常都如此）。

使用聚簇因子较好的索引读取数据，即使所需要读取的行数较多，也能因为读取数据块数较少而能够获得非常好的读取效率。在频繁需要读取大范围数据的情况下，为了提高读取效率而采用有利于数据读取的存储方式会显得非常重要。

**如果表中行的存储顺序与我们经常读取较大范围行的顺序一致，则就能够在很大程度上提高读取效率。**

提高聚簇因子的有效方法有很多，但这些方法的不足之处就在于在数据存储时需要付出的代价较大。**在提高聚簇因子方面显得最无效的方法就是堆表**，因为这种表结构所采用的并不是对数据的存储具有强制约束性的固定存储方式，而是按照数据插入的顺序进行存储的随机存储方式。

即使我们所期望的数据存储顺序与数据生成的顺序不一致，也不应当为此而耿耿于怀。只需要**定期对表执行重构操作就可以达到所期望的效果**。然而，我们绝对不可以忽视表重构操作的代价，而且它的代价并不像我们想象的那么小。因此，表的重构操作也不是随心所欲的事情。
