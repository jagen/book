# 数据的存储结构和特征

## 1.1 表和索引分离型

所谓的表和索引分离型的存储结构其实就是堆表，即用来存储数据的表和为了快速查找特定数据而使用的索引完全作为不同的对象来存储。

从代价的角度来分析，由于需要执行两次查找，即键的查找和数据的查找，必然会存在额外的代价。

使用键和数据分离的方法在存储数据时不会受到索引的任何影响，从这一角度来看，又在很大程度上减少了代价的支出。

虽然为了便于今后查找，而需要花费时间和经历将物品的存放位置记录在手册中，但这件事情完全可以放在空闲时间去做。而在存放物品时，如果能不用顾忌其他而有限无条件地将物品放入抽屉，则会在很大程度上减轻存放时的负担。

**数据和索引分别独立存储的数据存储结构具有非常重要的意义。**

表和索引互相分离、各自作为不同的对象存储是关系型数据库中最常见的数据存储方式。尽管这种存储方式有一些缺点，但是它在有效管理海量数据方面却是最佳方式。

### 1.1.1 堆表的结构

数据由一个个的Block构成，每个Block按照预先设定的未使用空间比例值（PCTFREE）和已使用空间比例（PCTUSED）来确定该数据块是否进入Free List中。被放入Free List中的Block可以被插入数据。

数据的存储方式完全与数据值之间没有任何联系，只是按照先后顺序无条件地将其插入到数据块中。

如果一个Block不是空的，数据必须被存储在Block中的空余空间里。如果Block中没有可以用来存储一整行数据的连续空间，但又要确保能够把同一行数据存储在这个数据块里时，必须对该数据块中的全部数据执行空间再分配操作（Condensing）。**数据块的下方的Free Space，并不是为插入新数据而预留的空间，而是为修改操作预留的。**它是在定义数据块时，通过设置参数PCTFREE来指定的。

采用随机存储方式虽然在某种程度上减少了数据存储时的代价，但是我们并不只是以存储数据为最终目的，而是以数据的读取和灵活运用为目的，所以绝不能对数据读取时的代价置之不理。

代表一行数据的ROWID，可以由4个部分构成，即对象编号（Object No）、数据文件编号（Datafile No）、数据块编号（Block No）和数据槽编号（ Slot No）。

行的ROWID不是存储在表中而是被存储在索引中。

所谓的**表空间（Table Space）**是指逻辑性的存储空间，它就类似于小区所占用的土地，或者类似于为了给建筑综合福利设施而提前准备好的土地。这种土地的位置、大小、种类等都是由不同用途的地块组合而成的。同样，表空间是由一个或多个物理文件（Datafile）构成的。

表空间按照用途可以被划分为不同用途的段（Segment），在段里创建对象（Object）。对象必须被创建在于其用途相匹配的段中。

某个表或某个索引中的数据非常多时，为了便于管理，通常我们会为其创建分区（Partition），而所创建的各个分区都是作为独立的对象而存在的。当分区表中各个分区的空间使用超过了一个表空间的限制时，可以将这些分区存储在多个表空间中。但是，个别分区表或非分区表都必须被存储在同一个表空间中。

对数据文件的识别并不是利用绝对文件号来进行唯一识别的，而是以表空间为单位为其赋予了相对号码，仅在一个对象中用其来唯一识别各个数据文件。

依据ROWID的对象号和数据文件号就能找出行的物理存储位置，然后在此物理存储位置上依据数据块号码就能够查找出相应的数据块，最后在数据块中很容易就能够查找出指向该行的Slot号。ROWID并不是用来显示行具体的位置信息的，而只是用来显示这一行的Slot号而已。

无论数据块中行的位置如何发生变化，ROWID的值也不会发生任何变化。在存储数据时，尽量要确保某一行被连续地、不间断地存储在某个数据块中；否则，为了将同一行所占用的多个非连续的存储片连接起来是需要付出额外代价的。因此，当行的长度发生变化时，为了始终确保将同一行存储在连续的单一存储片上，只能在其所在的数据块中寻找能够存储该行的连续空余空间，并将其移动到该空间上来。尽管行的位置发生了变化，但是由于这种变化并没有对ROWID产生任何影响，所以这种变化是不需要付出任何额外代价的。

当行被移动到能够适合其存储的单一的、连续的存储片上的，由于只需要把当前Slot中的位置值变为新的位置值即可，所以行位置的随意变化不会对ROWID产生任何影响。如果行的存储位置经常发生变化，则会形成大量无法使用的小空闲碎片。尽管这些空闲碎片总的空间可能超过某个行所需要的存储空间，但是如果没有连续空闲空间能够满足新行的存储需要，那么新行仍然无法存储在这个数据块中，为了解决此类问题，在总空余空间足以存储某行但由于没有连续空间可用时，数据库系统会自动对此数据块中的全部数据执行**空间再分配操作**。

如果预先设置的空余空间过小，数据库系统就会频繁要求执行空间再分配操作，这就无形中增加了数据处理的负担。因此，即使行长变长的概率不大，只是会频繁的执行修改操作，也同样应当设置充足的空余空间（PCTTREE）。**设置充足的空余空间可以被认为是提高数据处理效率的重要手段之一**。

但是总有一个特殊情况，就是无论怎么操作，仍然无法将变成的行存储在当前数据块中，必须使用其他数据库时，就意味着必须更换ROWID，比较聪明的一个方法是利用旧ROWID寻找新的ROWID。这会导致为了读取这行数据需要读取两块数据，这与读取一个数据块相比增加了一倍代价，我们称这种现象为**行迁移（Migration）**。这种现象只有在删除行或表之后并重新为数据行分配空间时才能够消除。

与行迁移相似的概念为**行连接（Chain）**。倘若某个行所需要的存储空间大小超过一个数据块的空间大小时，无论使用什么样的方法也无法将其存储在同一个数据块中。此时，就必须把所需要的数据块连接在一起来存储这个较长的行，我们把这种方法称为行链接。

一般情况下，存储于数据块中的行的长度都是可变的。尤其是当行中具有NULL值时，对NULL值的修改是导致行长度发生变化的重要原因。**行长度的变化对DBMS而言，也就意味着为了确保行被存储在数据块中的单一存储片上，而努力调整预期匹配的位置**。对于这一操作而言，从DBMS的角度来看，是对行位置的调整；而从行自身的角度来看，是自身位置的移动。为了避免由于行位置的移动对索引产生影响，就必须使用前面所介绍的行迁移和行链接的方式来进行处理。由于在堆表结构中行迁移和行链接是无法避免的，所以无论哪种DBMS,都会以非常相似的方式来处理。

### 1.1.2 聚簇因子

堆表的最大特征就是数据的独立存储性，即数据的存储于数据值没有任何关联地被存储在磁盘的任意位置上。从另外一个侧面来看，该特征也意味着为了查询我们所需要的数据必然要在磁盘的多个位置上进行查找。

**随机存储方式就是数据所占据的位置分散在不同的数据块上**。

在这种存储状态下，查询相同数据所执行的物理读取数量会随着查询数据的分散程度而不同。例如，数据行1~10被分散存储在10个数据块与两个数据块相比较，虽然两种情况逻辑读取的数据行数（都是10行）是相同的，但在物理（I/O）读取的数据块数上却相差5倍。

在关系型数据库中，不论在何种情况下，每次最少都需要读取一个数据块。尽管我们每次要求读取的是行，但实际上每次读取的却是数据块。因此，如果能够在内存中命中我们所需要查询的数据行，则在很大程度上就能够减少物理I/O的数量。

数据被存储的越集中，数据读取效率越高；数据被存储得越分散，数据读取效率越低下。

数据的物理存储方式是数据存储时决定的，且物理存储方式只能按照一种顺序存储数据，所以顺序一旦被决定就不能根据读取条件而随心所欲地改变。不论我们采取何种存储方式来存储数据，最终都会使得每一个列值的存储集中程度与其他列值的存储集中程度之间出现一定的差异。

**聚簇因子是指，按照索引列值进行了排序的索引行序和对应表表中数据行序的相似程度。**

在所有的表类型中，尤其是在堆表中，聚簇因子显得格外重要。聚簇因子的大小对数据读取效率有着直接的影响。

通常对存储在表中的行执行删除操作并不会频繁出现，并且修改操作导致列的长度变短的情况也比较少见。通常我们会尽量重复使用现存数据而尽量避免新增数据，因此通常数据插入操作的情况同样也比我们想象的要少（这种现象虽然会随着表特征的不同而不同，但是通常都如此）。

使用聚簇因子较好的索引读取数据，即使所需要读取的行数较多，也能因为读取数据块数较少而能够获得非常好的读取效率。在频繁需要读取大范围数据的情况下，为了提高读取效率而采用有利于数据读取的存储方式会显得非常重要。

**如果表中行的存储顺序与我们经常读取较大范围行的顺序一致，则就能够在很大程度上提高读取效率。**

提高聚簇因子的有效方法有很多，但这些方法的不足之处就在于在数据存储时需要付出的代价较大。**在提高聚簇因子方面显得最无效的方法就是堆表**，因为这种表结构所采用的并不是对数据的存储具有强制约束性的固定存储方式，而是按照数据插入的顺序进行存储的随机存储方式。

即使我们所期望的数据存储顺序与数据生成的顺序不一致，也不应当为此而耿耿于怀。只需要**定期对表执行重构操作就可以达到所期望的效果**。然而，我们绝对不可以忽视表重构操作的代价，而且它的代价并不像我们想象的那么小。因此，表的重构操作也不是随心所欲的事情。当然，表重构操作的代价也并不是很大，即使表中存储的是海量数据也不用担心，因为现在DBMS的功能不断提高，并且此项操作通常都是放在空闲时间来实施的，所以不会给系统造成太大的负担。

对并重构操作影响最大的因素是并行处理（Parallel Processing）。

在堆表结构中，应当从战略性的高度对将要存储的列的顺序，予以综合性的分析和判断。

### 1.1.3 影响读取的因素

堆表的结构特征会对数据读取效率产生很大的影响。

#### 1.1.3.1 大范围数据读取的处理方案

在堆表中，由于数据是按照插入顺序被存储在磁盘的任意位置上的，所以存储时所需要付出的代价相对较少。但是在读取满足特定查询条件的数据时，所需要付出的代价则相对较大。

在必须要处理海量数据的情况下，所采用的处理方案从根本上就应与面对少量数据时不同。堆表在管理海量数据方面具有其他类型表无法比拟的优势。在堆表结构中，由于处理海量数据的各种解决方案（并行处理、分区、各种索引等）都可以使用，所以在现实中有很多用户都在使用堆表来存储海量数据。

即便在预测到将要处理的数据量会非常大的情况下，也仍然可以选择使用堆表来存储数据，这主要是因为这可以减轻数据插入时的负担。

在大部分的RDBMS中，都是只在内存中对用户要求的数据进行处理，然后等到闲暇时再将处理结果从内存中移出并存储在磁盘的合适位置上。我们将此方法称为延迟写入（Deffered Write）。

堆表所具有的唯一优点就是在数据插入时不需要采取任何特别的措施，只需顺其自然按照数据插入的顺序存储，因此减少了插入大量数据时的代价。仅此而已，再无其他任何优势可言。

* 小型表
小型表就是指表中所存储的数据量相对较少。由于小型表数据块数量相对较少，重复读取缓存在内存中的概率也相对较大，所以尽管是随机读也能获得非常好的数据读取效率。

* 中型表
中型表是指，位于处理代价非常大的大型表与处理代价非常小的小型表之间的所有表。在几乎所有的分类中，位于中间的类型通常都是最一般且所占比例最大的部分。中型表在数据插入时的负担不像大型表那样会对整个系统有着决定性的影响，但是它在各种应用中频繁被读取的概率相对来说较大。
按照固定存储方式只能确保一种存储顺序，所以也只是在读取特定列时能够获得较好的效率。使用以某个特定顺序存储数据的方法并不能满足所有的读取要求。这主要是因为这种存储方法只能确保在特定的读取类型中获得较好的效率。**从理论上来看，根本就不存在一种能够满足所有读取要求的数据存储方式。**
从任意列的角度看，不论采用何种方式对数据进行存储，整个表中的数据都将被认为是分散地存储着的。
首先，选定最为重要的读取类型；
其次，通过调查分析来决定是否有必要为该读取类型采取一些特殊的措施。
**对于世界上的所有问题而言，我们始终追求的最理想解决方案就是以最少的代价换取最大的回报。**
对于大型表而言，不仅数据插入的负担比较大，数据读取的类型也比较多，所以采用堆表会比较有效。
我们无法单一地通过选择数据的存储结构来提高所有数据读取类型的效率。

* 大型表
大型表可以分为三类：
  1. 单纯的存储型。日志管理比较常见，不会有多样化的读取要求。
  2. 顾客类表。主要以随机读取为主，不并不存在多样化的读取类型。
  3. 销售类表。不仅数据急速大量增加，而且具有多样化的数据读取类型。一般情况下，拥有这种特征的表对系统会产生极大的影响。不论从数据管理的角度还是从数据读取的角度看，都具有非常大的负担。

如果急速增加的数据对管理造成了很大的负担，则应当当机立断为其创建分区。

#### 1.1.3.2 提高聚簇因子的手段

凝聚，是指把经常需要读取的数据集中存储在相似的位置上。这是为了拥有较好的聚簇因子都采取的措施。但是使用堆表存储数据时，无法以强制性的方式来控制数据的存储，所以需要**定期地对表执行重构操作。**

表的重构并不高深，但是很有效。可以**定期地对表执行重构操作**。

对表执行重构操作主要是为了提高执行速度，大部分情况下并不是以提高凝聚度为目的，而是以减少行链接和提高数据块中数据的存储率并缩减不必要的I/O为目的。

**表的重构操作之所以能够在一定程度上获得好的效果，主要是因为在对表执行重构操作的同时，相应的索引也会被重构。**

**对经常需要查询的列值进行排序，并按照此顺序存储新插入的数据。** 当然，即使使用了这种方法，数据的凝聚度也会随着时间的流逝而不断变低。只是由于已经存储在磁盘上的数据的存储位置发生变化的概率非常小，所以使用此方法能够在相当长的时间里维持较好的效果。

在对表执行重构操作时需要注意的是，**在把数据存储到表中时，该表中的所有索引都应当被删除或者将其状态设置为无效（Disable）。** 如果在索引不被删除或者没有改变其状态的情况下向表中存储大量的数据，则不仅会使表存储数据的速度变得非常缓慢，而且还会由于大量分割导致索引的存储密度被大幅度地降低。这样一来不仅造成了空间浪费，而且也在很大程度上降低了索引的效率。

## 1.2 索引组织表

B-Tree索引是最一般也是最常用的索引，它由“索引列+ROWID”构成。

索引组织表是指把索引和一般数据列全部存储在相同位置上的表结构。因此，如果读取了索引，就没有必要再次读取表了。

如果大部分的查询语句都要求对主键进行扫描，且主键的长度在整个行的长度中所占的比例比较大，则就没有必要分开索引和表了。在此情况下，索引组织表是最佳的选择，因为不仅不用另外为表创建索引，而且还可以提高数据的读取效率。

### 1.2.1 堆表和索引组织表的比较

| 比较项              | 堆表（Heap Table）     | 索引组织表（Index-Organized Table）                                                               |
| ------------------- | ---------------------- | ------------------------------------------------------------------------------------------------- |
| 行的唯一识别        | ROWID                  | 主键                                                                                              |
| 主键是否必须指定    | 可以不指定             | 指定（主键必须存在）                                                                              |
| Secondary索引的创建 | 使用ROWID              | 逻辑ROWID或者Bitmap索引                                                                           |
| 行的读取            | 使用ROWID进行行读取    | 使用主键进行行读取                                                                                |
| 全表扫描            | 按照任意顺序将返回行   | 按照主键的顺序返回行                                                                              |
| 能否使用聚簇        | 可以                   | 不能                                                                                              |
| LONG，LONG RAW，LOB | LONG类型的列只能有一个 | 不能有LONG类型的列                                                                                |
| Distributed SQL     | 允许                   | 因版本不同而有所差别                                                                              |
| Data Replication    | 允许                   | 因版本不同而有所差别                                                                              |
| 分区的应用          | 允许                   | 因版本不同而有所差别                                                                              |
| 并行处理            | 允许                   | 因版本不同而有所差别；通过CTAS加载数据；分区和一般IOT并行高速全表扫描(FFS)；分区IOT的并行索引扫描 |

### 1.2.2 索引组织表的结构和特征

索引组织表的最大优点并不是不经过索引而减少了一次逻辑读所形成的数字上的差异。索引组织表的优势是在大范围的数据扫描中可以获得非常高的读取效率。使用索引组织表即使扫描大范围数据，所需要付出的代价相对而言也不会很大。

在索引组织表中，由于索引列和一般的数据列存储在一起，如果只从索引的立场来看，用来存储索引数据的数据块相对而言会比较分散。因此，在索引组织表中如果只进行索引扫描，则索引的扫描效率反倒不如堆表的索引效率高。

**索引组织表中由于索引列和一般的数据列是存储在一起的，所以就会有很大程度上提高行长度变长的概率。**

### 1.2.3 逻辑ROWID和物理猜（Physical Guess）

索引组织表中的数据被存储在B-Tree索引的叶块（LeafBlock）中，在B-Tree随着数据的增加而不断生长的同时，用来存储键值（这里指的是索引列值）的块（Node）就会被分割，致使某个相同的键值无法继续被存储在同一个块中。

**索引组织表中的数据无法拥有永久的物理地址。因此，也就无法使用物理地址ROWID来唯一识别存储在数据块上的行。** 在索引组织表中为了识别行的位置，所能够采用的唯一方法就是使用主键来代替ROWID。

实践证明，只要按照使用准则来正确地使用索引组织表，就一定能够获得较好的效果。适用索引组织表的情况如下所示：

* 电子分类或者关键字查询表。
* 代码信息表。
* 索引表。
* 空间信息管理表。
* 大部分使用主键查询的表。
* OLAP的维度表。
* 记录的长度相对较短，且插入操作不频繁发生的表。

如果物理位置信息的正确率变得非常低，重构操作的代价又非常大，则应当提前创建统计信息，以便为优化器在决定是否选择使用物理位置信息时提供参考。

### 1.2.4 溢出区（Overflow Area）

尽管把索引和所有列存储在一起对读取数据比较有利，但是这样的方法却容易导致块的分割和存储密度的降低，不论是块的分割还是存储密度的降低都会导致读取代价的增大。行的长度越长，数据增加得越快，这两种现象发生的概率就会变得越大。

**把不经常使用的列存储在溢出区中，缩减与索引一起存储的行的长度，可以有效的解决上述问题。**

**索引组织表的所有列（溢出区中的列除外）被存储在索引段中，溢出区中的列被存储在表段中。** 为了在索引段中能够正确地查找到溢出区中的数据行，就需要使用ROWID。不论索引组织表所占据的索引段还是溢出区所占据的表段，都是相互独立的物理存储空间，所以可以为他们制定不同的表空间（Table Space）。

### 1.2.5 创建索引组织表

**在索引组织表中，按照何种类型发生行链接要比行链接是否发生更重要。** 行链接是提高叶块中数据存储密度的重要战略方案，这主要是因为对索引区和溢出区进行战略性的区分能够提高数据的读取效率。

## 1.3 聚簇表

在处理海量数据时，由于堆表要执行大量的随机读，这就在很大程度上增加了读取的代价；尽管索引组织表在特定的读取要求下不在需要执行随机读，但当存在多样化的读取类型时也同样需要付出非常大的读取代价，这就使得索引组织表也无法适用于海量数据的处理。

在最终的绝对处理范围比较大的情况下，无论怎么灵活运用索引，都无法避免执行大量的随机读。

**对于海量数据处理而言最具有使用价值的就是聚簇。**

### 1.3.1 聚簇表的概念

聚簇的概念会随着DBMS的不同而有所不同，但使用聚簇所追求的目标几乎都是相同的。

聚簇就像表和索引一样是拥有自己独立存储空间的一种对象。

**像表是索引的上级概念一样，聚簇是表的上级概念。**虽然各自都是相互独立的对象，但是在概念上却有一定的从属性。换言之，可以在使用聚簇所创建的对象中创建表。

在相同的聚簇中创建表，把表建在相邻的位置，以提高联合查询效率。这种方法叫“**复合表聚簇**”。

为了能够有效地读取大范围的数据，而把具有某种相同性质的数据聚簇在一起的方法，称之为“**单表聚簇**”。

虽然复核表聚簇和单表聚簇在原理上基本相同，但在使用目的上却有着很大差别。

**利用聚簇索引来查找数据的聚簇类型称为索引聚簇，把利用哈希函数来查找数据的聚簇类型称为哈希聚簇（也被称为散列聚簇）。**

聚簇表与一般的表相比唯一的不同之处就在于，它按照特定的列（聚簇键）把数据聚簇在了一起，从而在一定程度上提高了聚簇因子。

**使用聚簇的最终目的，是在RBO模式（基于规则的优化Rule-Based Optimization）下为特定数据的读取赋予更高的优先顺序，在CBO模式（基于代价的优化Cost-Based Optimization）下减少大范围数据读取的代价。**

一个表只能从属于一个聚簇，不能同时从属于两个或者两个以上的聚簇。

**所谓的聚簇就是指以某个指定的列为基准，把拥有相同聚簇键值的所有行都存储在相同位置上的物理存储方法。**把多个表中拥有相同聚簇键值的行集中存储在连续位置上的做法，意味着把需要执行表连接的行提前集中存储在了一起，从而能够显著地降低表连接时的数据运输单价。相类似地，把同一表中拥有相同聚簇键值的行集中存储在连续位置上的做法，能够显著地降低读取海量数据时的运输单价。

**使用聚簇的主要目的就是为了提高聚簇因子。**
**聚簇因子就是指我们所要读取的数据在多大程度上被集中存储在一起。**

### 1.3.2 单表聚簇

**单表聚簇是指在指定的聚簇中只创建一个表的聚簇结构。**

单表聚簇如果能够合理的利用，则能够使得数据的读取效率比原来提高5~8倍。聚簇表之所以能够如此大的程度上提高数据的读取效率，并不是因为它具有某种特殊的数据处理机制，而是因为在此结构中只要读取一个索引行就能够连续读取多个数据行。聚簇索引与一般索引除了这一差异之外再无其他任何差异。

从聚簇结构中我们可以看出，由于它需要把数据存储在特定的位置上，所以对插入、修改等操作而言，所需要付出的代价相对较大，并且这些操作代价的大小会随着具体情况的不同而不同。

### 1.3.3 复合表聚簇

**复核表聚簇是指在一个单位聚簇中存储两个或两个以上的表的聚簇结构。**由于具有相同聚簇键值的不同表中的行被存储在互相邻近的位置上，所以在执行表连接时能够在很大程度上提高执行速度。

尽管两个表被存储在同一个单位聚簇中，但这并没有破坏他们之间的独立性。表被创建在任意位置上时表之间的独立性不会受到任何影响，我们把这个属性称之为“局部透明性”。

聚簇中各个独立的表不仅可以被单独读取，而且也可以创建自己独立的索引。**之所以把两个或两个以上的表以聚簇的形式来进行存储，主要是为了提高这些表的连接效率。**

在实际应用中，只有在非常特殊的情况下使用聚簇才能获得比较理想的效果，即**使用聚簇在提高具有特殊关系的表连接效率方面具有非常明显的效果。**然而，强制性地把某几个表聚簇在一起的做法却破坏了表的弹性。

**除了不可分的关系之外建议尽量为各个表赋予更高的独立性。**

### 1.3.4 聚簇表的代价

单表聚簇解决了关系型数据库中最难解决的问题——大范围数据处理。复合聚簇则在很大程度上提高了特定表连接的效率。但是我们也必须为此付出相应的代价。

聚簇只是在数据查询时能够提高数据的读取效率，但在数据的插入、修改、删除中却需要付出额外的代价。
