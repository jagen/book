# 第二章 基本解析结构

* 从文法到递归下降识别器，这种模式展示了将文法（形式化的语言语言定义）手动转化为解析器的过程；
* LL(1)递归下降词法分析器，这种模式把字符流分解为词法单元（token），以供其他解析模式使用；
* LL(1)递归下降语法解析器，这是最有名的递归下降语解析模式。它只根据当前的输入字符来决定如何解析，并且对文法中的每条规则都提供了相应的解析方法；
* LL(k)递归下降语法解析器，这是LL(1)的增强模式，它最多向前看k个输入字符来决定如何解析。

## 识别式子的结构

自然语言句子中可以划分出不同的语言成分，如动词和名词。计算机语言也有，程序中变量、操作符等词汇表中的符号（词法单元）各有不同的功能，甚至还要区分出词法单元组成的式子（如表达式）。

解析树的叶节点是词法单元，分支节点表示式子的子结构。

解析树很重要，里面还有式子的所有语法（结构）信息。而解析就是将线性的词法单元序列组成带有结构的解析树。

## 构建递归下降语法解析器

语法解析器能够检查句子的结构是否符合语法规范（语言就是合法句子的集合）。为了验证句子是否合法，解析器必须识别句子的解析树。

解析器不必构造具体的解析树，因为只要为解析树中的制定结构（树的内节点）编写专用的函数，就能从解析函数的调用顺序（调用树）中隐含地得到解析树的信息。

**例子1** return x+1

```Java
void stat()         { returnstat(); }
void returnstat()   { match("return"); expr(); match(";"); }
void expr()         { match("x"); match("+"); match("1"); }
```

**例子2** if x<0 then x=0;

```Java
void stat() {
    if (<<向前看词法单元 return>>)              returnstat();
    else if (<<向前看词法单元是 identifier>>)   assign();
    else if (<<向前看词法单元是 if>>)           ifstat();
    else <<解析错误>>
}
```

这种解析方式从解析树的顶部开始处理，一直向下处理，直到叶节点，因此得自顶向下语法解析器。

**下降**表示自顶向下；**递归**表示这些函数可能会调用自身。

这是向前看一个词法单元的自顶向下解析器，规范名称为LL(1)。两个L都代表left-to-right，第一个L表示解析器按“从左到右”的顺序解析输入内容；第二个L表示下降解析器时也是按“从左到右”的顺序遍历子节点。

解析器的步骤基本就是：

1. 预测子句的类型；
2. 调用函数来匹配子结构；
3. 匹配词法单元；
4. 按照需要插入代码，执行自定义操作。

手工编写这种解析器做多了会感到乏味，因为解析器里所用的函数大多功能类似、结构单一严谨、所以很容易采用自动生成来完成。

## 使用文法DSL来构建语法解析器

直接编写递归下降解析器既繁琐又容易出错，编写时得反复地输入一些结构相同、写法类似的代码。而如果用专用的DSL来描述语言，就能提高实现的效率。这个DSL所能编写的程序就是文法，能将文法翻译为解析器的工具称为**解析器生成器**。

解析树中的子结构及解析器中的函数，都对应于文法中的规则。子结构的子节点相当于规则右变得词法单元，而解析器中的if-then-else形式的分支跳转相当于规则中表示子结构选择的竖杠“|”.

前面所描述的解析器，形似如下：

``` flex
stat        : returnstat                // "return x+0;" 或者
            | assign                    // "x+0;" 或者
            | ifstat                    // "f x<0 then x=0;"
            ;
returnstat  : 'return' expr ';' ;       // 加单引号的字符串是词法单元
assign      : 'x' '=' expr ;
ifstat      : 'if' expr 'then' stat ;
expr        : 'x' '+' '0'               // 出现在returnstat中
            | 'x' '<' '0'               // 出现在if条件分支中
            | '0'                       // 出现在复制中
            ;
```

## 词法单元和句子

能处理输入字符流的识别器，一般称为**词法单元解析器**或**词法解析器**。完整的句子往往具有自己的结构，每个词法单元也有结构，字符的语法一般称为**词法**。

前面用文法描述语言的结构，而这里也用类似的方法描述词法单元。

**例子1** 整数和标识符的定义

``` flex
Number  : '0'..'9'+ ;               // 若干个数字（0..9）
ID      : ('a'..'z'|'A'..'Z')+      // 若干个字幕
```

给之前的expr规则加入范围更广的变量名和整数

``` flex
expr    : ID '+' Number             // 出现在returnstat中
        | ID '<' Number             // 出现在if条件分支语句中
        | Number                    // 出现在赋值语句总
        ;
```

**例子2** 识别[a,b,c]这样的列表以及[a,[b,c],d]这种带嵌套的列表

``` flex
grammar NestedNameList;
list        : '[' elements ']' ;            // 匹配方括号
elements    : element (',' element)* ;      // 匹配list的逗号
element     : NAME | list ;                 // element是NAME或嵌套的list
NAME        : ('a'..'z'|'A'..'Z')+ ;        // NAME含有至少一个字母
```

讨论完文法和解析之后，可以定义4种经典的解析模式。根据这些模式，可以为各种语言编写解析器。

## 模式1 从文法到递归下降识别器

### 目的

本模式能根据语言的文法，生成能匹配语言中式子和语句的递归下降识别器。

此模式与所有递归下降的词法解析器、语法解析器或者树解析器的核心控制框架形同。

### 讨论

即使打算手工编写词法解析器或语法解析器，也最好先制定语言的文法，因为文法能够精确地描述待识别的语言，而且，它还是良好的文档资料，可以写入参考手册或者注释到代码中。

这种模式能处理大部分文法，但对有些文法却无能为力。
